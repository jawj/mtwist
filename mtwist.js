// Generated by CoffeeScript 2.5.1
(function() {
  var MTwist;

  MTwist = class MTwist {
    // Mersenne Twister drop-in replacement for Math.random, 
    // including the 2002 improvements to initialization
    // Copyright 2014 George MacKerron 
    // Released under the MIT Licence: http://opensource.org/licenses/MIT
    constructor(seed = Math.random() * 4294967295) { // seed with a 32-bit integer
      var k, mti, uint32mul;
      this.randomUInt32 = this.randomUInt32.bind(this);
      this.random = this.random.bind(this);
      this.randomIntBelow = this.randomIntBelow.bind(this);
      this.randomIntBetween = this.randomIntBetween.bind(this);
      uint32mul = function(n1, n2) {
        var n1High16, n1Low16, n2High16, n2Low16;
        n1Low16 = n1 & 0x0000ffff;
        n1High16 = n1 >>> 16;
        n2Low16 = n2 & 0x0000ffff;
        n2High16 = n2 >>> 16;
        return ((((n1 & 0xffff0000) * n2) >>> 0) + (((n1 & 0x0000ffff) * n2) >>> 0)) >>> 0;
      };
      this.mt = new Array(624);
      this.mt[0] = seed >>> 0;
      for (mti = k = 1; k < 624; mti = ++k) {
        this.mt[mti] = (uint32mul(1812433253, this.mt[mti - 1] ^ (this.mt[mti - 1] >>> 30)) + mti) >>> 0;
      }
      this.mti = mti;
    }

    randomUInt32() { // [0,0xffffffff]
      var i, k, l, y;
      if (this.mti >= 624) {
        for (i = k = 0; k < 227; i = ++k) {
          y = ((this.mt[i] & 0x80000000) | (this.mt[i + 1] & 0x7fffffff)) >>> 0;
          this.mt[i] = (this.mt[i + 397] ^ (y >>> 1) ^ (y & 1 ? 0x9908b0df : 0)) >>> 0;
        }
        for (i = l = 227; l < 623; i = ++l) {
          y = ((this.mt[i] & 0x80000000) | (this.mt[i + 1] & 0x7fffffff)) >>> 0;
          this.mt[i] = (this.mt[i - 227] ^ (y >>> 1) ^ (y & 1 ? 0x9908b0df : 0)) >>> 0;
        }
        y = ((this.mt[623] & 0x80000000) | (this.mt[0] & 0x7fffffff)) >>> 0;
        this.mt[623] = (this.mt[396] ^ (y >>> 1) ^ (y & 1 ? 0x9908b0df : 0)) >>> 0;
        this.mti = 0;
      }
      y = this.mt[this.mti++];
      y = (y ^ (y >>> 11)) >>> 0;
      y = (y ^ ((y << 7) & 0x9d2c5680)) >>> 0;
      y = (y ^ ((y << 15) & 0xefc60000)) >>> 0;
      y = (y ^ (y >>> 18)) >>> 0;
      return y;
    }

    random() { // [0,1), like Math.random
      return this.randomUInt32() / 4294967296; // 2^32
    }

    randomIntBelow(maxPlusOne) { // [0,n) with proper uniform distribution (see WARNING at http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/efaq.html)
      var bitMask, bitsNeeded, int;
      if (maxPlusOne < 1) {
        throw "Upper bound must be greater than or equal to 1";
      }
      if (maxPlusOne > 4294967296) {
        throw "Upper bound must not be greater than 4294967296";
      }
      if (maxPlusOne === 1) {
        return 0;
      }
      bitsNeeded = (maxPlusOne - 1).toString(2).length;
      bitMask = (1 << bitsNeeded) - 1;
      while (true) {
        int = this.randomUInt32() & bitMask;
        if (int < maxPlusOne) {
          return int;
        }
      }
    }

    randomIntBetween(inclusiveMin, inclusiveMax) { // [m,n]
      return inclusiveMin + this.randomIntBelow(inclusiveMax - inclusiveMin + 1);
    }

    static test() { // returns true if answer is as calculated using official C implementation
      var i, iterationFactor, iterations, j, k, l, mtwist, ref, seed;
      seed = 1234567890;
      iterationFactor = 10000; // makes max iterations about 400,000
      for (i = k = 0; k < 1000; i = ++k) {
        mtwist = new MTwist(seed);
        iterations = Math.floor(mtwist.randomUInt32() / iterationFactor);
        for (j = l = 0, ref = iterations; (0 <= ref ? l < ref : l > ref); j = 0 <= ref ? ++l : --l) {
          mtwist.randomUInt32();
        }
        seed = mtwist.randomUInt32();
      }
      return seed === 1240212512;
    }

  };

  module.exports = MTwist;

}).call(this);
